# Key Tipleri

Rx ile çalışırken anlanması gereken iki temel key tipi ve bunların yardımcı alt sınıf tipleri vardır. Bu iki yapı taşı, artık çok fazla duyacağımız, `Observable` ve `Observer`'dır. Aynı zamanda, bu sayfanın devamında `Observable`'ın alt sınıfı olan ve Rx öğrenmeyi kolaylaştıran `Subject` sınıfını da göreceğiz.


## Observable
Inceleyeceğimiz ilk temel sınıf [Observable](http://reactivex.io/documentation/observable.html) sınıfıdır. Bu sınıf, tüm temel operatörler de dahil fazla sayıda Rx implementasyonu içerir. Bir `Observer`, `Observable`'a subscribe olur. `Observer`, `Observable`'ın yaydığı bütün değerlere karşı bir reaksiyon verir. Bu yapı eş zamanlı operasyonları(Concurrency) kolaylaştırır çünkü `Observable`'ın verileri dağıtmasını beklerken thread engellenmez, bunun yerine `Observable`'ın eylemlerine tepki vermek üzerine bekleyen bir `Observer` formu oluşturur.

Dökümanın kalanında kitabına uygun şekilde adım adım ilerleyeceğiz. İlk olarak `Subscribe` metodunu ele alalım.

```java
public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
            Action onComplete)
```

Bu metod `Observable` tarafından yayılan değerleri karşılar ve dönüş değeri olarak bir `Disposable` instance'ı döner.

## Observer
`Observer` interface'ini ve sahip olduğu metodları görelim.

```java
interface Observer<T> {
    void onSubscribe(@NonNull Disposable d);
    void onNext(@NonNull T t);
    void onError(@NonNull Throwable e);
    void onComplete();
}
```

`onSubscribe` dışındaki üç metod `Observable` tarafından bir değer iletildiğinde, iletilen değerleri karşılayan metodlardır. `onSubscribe` ise `Observable`'a subscribe olunduğu an tetiklenir. `onNext` metodu, subscribe olunan `Observable`'ın yapısına göre, 0 ya da daha fazla kez çağrılabilir. `onNext`'i opsiyonel olarak `onError` ya da `onComplete` izler. `onError` ve `onComplete`'den sonra bir aksiyon olmaz, `Observable`'ın yaşam döngüsü sonlanmıştır.

## Subject
`Subject`'ler, `Observable` sınıfından türüyen ve `Observer` interface'ini implement eden bir sınıftır. Bu yüzden hem `Observable` gibi hem de `Observer` gibi davranabilir. 

* Bir ya da daha fazla `Observable`'a subscribe olabilir ve kendi eventleri vardır, bu bakımdan `Observer`'dır. 
* Ona subscribe olunabilir ve subscriberlarına değerler iletebilir. Bu bakımdan `Observable`'dır.

Ne kadar çılgın görünse de,`Subject`'ler Rx'e başlamak için ideal noktadır. Dışarıdan gelen verileri bir `Subject`'e iletibilir ve onları observable'a çevirebilir. Birçok farklı `Subject` türü vardır. Biz en önemlilerinden sayılanları inceleyeceğiz.

### PublishSubject
`PublishSubject`, `Subject`'ler arasında genel anlamda en klasik olanıdır. `PublishSubject`'e bir değer gönderildiği zaman, bu değer bütün subcriberlarına iletilir.

```java
PublishSubject<Integer> subject = PublishSubject.create();

subject.onNext(1);
subject.subscribe(System.out::println);
subject.onNext(2);
subject.onNext(3);
subject.onNext(4);
subject.onComplete();
subject.onNext(5);
```

```diff
- Output 

2
3
4
```

Görüldüğü üzere 1 basılmadı çünkü 1 değeri `onNext` ile iletildiğinde o henüz subscribe değildik. Subscribe olduktan sonra iletilen değerleri almaya başladık. 5 basılmadı çünkü `onComplete` ile `Subject`'in yaşam döngüsünü sonlandırdık.


- `subscribe` fonksiyonunun parametre olarak aldığı, [Functions](http://reactivex.io/RxJava/javadoc/rx/functions/Functions.html) package'ından [Consumer](http://reactivex.io/RxJava/javadoc/io/reactivex/functions/Consumer.html) interface'ini overload ettik. Bu interface'in metodu sadece bir değer alan `void` bir metottur.

```java
public interface Consumer<T> {
    void accept(T t) throws Exception;
}
```
- İletilen değeri kullanmak için [Lambda notasyonu](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) kullandık.

### ReplaySubject
`ReplaySubject`, kaynak `Observable`'a iletilen değerleri cacheleyerek, subscribe olma zamanına bakmaksızın bütün subscriberlarına yayar. Yeni bir subscription yapıldığında, o ana kadar `onNext` iletilen bütün değerleri sırasıyla iletir. Yeni subscriber, diğerleri ile eşitlendiği zaman yeni gelen değerleri almaya başlar.

```java
ReplaySubject<Integer> s = ReplaySubject.create();	
s.subscribe(v -> System.out.println("Birinci :" + v));
s.onNext(0);
s.onNext(1);
s.subscribe(v -> System.out.println("İkinci : " + v));	
s.onNext(2);
```

```diff
- Output 

Birinci: 0
Birinci: 1
İkinci: 0
İkinci: 1
Birinci: 2
İkinci: 2
```

Her şeyi cachelemek hiç iyi bir fikir olmadığından, kaç tane değerin cacheleneceğini sınırlandırabiliriz. Vereceğimiz sınır, subscription yapılan son X tane itemi alarak devam eder.




