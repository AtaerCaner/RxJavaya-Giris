# Yaşamdöngüsü Yönetimi

Rx kodunun doğası, bir `Observer` olarak dizinin ne zaman değer ileteceğini veya sonlanacağını bilmiyor olmanızdır; ama bu belirsizlik iletilen değerleri almaya başlamanız ya da durdurmanız üzerindeki kontrolünüzü etkilemez. Rx, subscription'ın yaşamdöngüsü boyunca, sorgulara sıkı bir kontrol sağlar. İşimiz bittiğinde dağıtılan kaynakları serbest bırakıp yolumuza devam edebiliriz. Bu, kaynaklarınızı en verimli şekilde nasıl yönetebileceğimize dair kararlar vermenize olanak tanır; aynı zamanda scope'u olabildiğince küçültmeniz için idealdir.

## Subscribing
`Observable.subscribe`'ın birkaç overload'u vardır. Bunlar;

```java
Disposable 	subscribe()
Disposable 	subscribe(Consumer<? super T> onNext)
Disposable 	subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError)
Disposable 	subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete)
Disposable 	subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Consumer<? super Disposable> onSubscribe)
Disposable 	subscribe(Observer<? super T> observer)
```

`subscribe()` event'e subscribe olur ama bir aksiyon beklemez. Bir ya da daha fazla `Consumer` alan overload'lari, metodları ile birlikte bir `Disposable` oluşturur. Eğer bir action verilmezse, event görmezden gelinecektir.

Aşağıdaki örnekte, sonunda bir hata alan işlem dizisi görebiliriz.

```java
Subject<Integer> s = ReplaySubject.create();
        s.subscribe(
                v -> System.out.println(v),
                e -> System.err.println(e));
        s.onNext(0);
        s.onError(new Exception("Oops"));
```

```diff
- Output 

0
java.lang.Exception: Oops
```

Eğer hatayı karşılamak için bir fonksiyon yazmassak, `s.onError` satırında `Functions$OnErrorMissingConsumer` ile karşılaşacağız. Bu örnekte hatayı yollayan `s.onError` ve karşılayan `Consumer` aynı yerdeydi. Basit bir try-catch ile durumu çözebilirdik fakat çok bölümlü sistemlerde, çoğu zaman gönderen ve karşılayan farklı yerlerde olur. Eğer `subscribe` içinde hatayı karşılamazsak, `subscribe` bir hata oluşup işlem dizisini sonlandırıldığını asla bilemeyecektir.

## Unsubscribing
İşlem dizisi sonlanmadan da verileri almayı durdurabiliriz.  Her `subscribe` overload'u, aşağıdaki iki metodu içeren bir `Disposable` instance'ı döner.

```java
boolean isDisposed();
void dispose();
```
    
